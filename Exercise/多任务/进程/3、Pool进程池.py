# -*- coding:utf-8 -*-
''''''

'''

Pool:

    如果要创建大量的子进程，可以使用进程池的方式批量创建子进程
    
    Pool默认大小是CPU核数
    
    常用函数：
    
        *   apply_async(func[,args[,kwds]])
        
            -   使用非阻塞方式调用func（并行执行，
            阻塞方式必须等待上一个进程退出才能执行下一个进程），
            
            -   args: 传递给 func 函数的参数列表
            
            -    kwds：为传递给 func 函数的关键字参数列表
        
        *   apply(func[,args[,kwds]])
        
            -   使用阻塞方式调用 func 函数
            
        *   close()
        
            -   关闭 Pool，使其不再接受新任务
            
        *   terminate()
        
            -   不管任务是否完成，立即终止
            
        *   join()
        
            -  主进程阻塞，等待子进程退出，必须在 close 或 terminate 之后使用
'''

from multiprocessing import Pool
import os, time

def run_proc_task(name):
    print('子进程执行 %s (%s)' % (name, os.getpid()))
    time.sleep(3)
    print('子进程执行 %s  time = %.2f' % (name, time.time()))

if __name__ == '__main__':
    print('父进程 %s.' % os.getpid())
    p = Pool(4) # 创建4个进程
    for i in range(5):
        # async 异步
        # sync同步
        p.apply_async(run_proc_task, args=(i,)) # pool.apply_async()用来向进程池提交目标请求

    #  问题： 为什么会先执行此处打印，而不是执行子进程中的打印 ？？？？
    #   答：使用  apply_async(异步)方式向进程池中提交请求，所以会继续向下执行父进程中的代码
    #   使用 apply （同步或阻塞）方式时，会按照先打印子进程信息，所有子进程执行完成后，在打印父进程后的信息
    print('等待所有子进程执行完成...')
    p.close() # 关闭进程池,表示不能再往进程池中添加进程
    p.join() # 等待进程池中的所有进程执行完毕，必须在close()之后调用
    print('所有子进程执行完成...')


'''

执行结果：

    父进程 10148.
    等待所有子进程执行完成...    
    子进程执行 0 (6496)
    子进程执行 1 (9436)
    子进程执行 2 (9092)
    子进程执行 3 (5160)
    子进程执行 0  time = 1524379253.25
    子进程执行 4 (6496)
    子进程执行 1  time = 1524379253.25
    子进程执行 2  time = 1524379253.25
    子进程执行 3  time = 1524379253.30
    子进程执行 4  time = 1524379256.25
    所有子进程执行完成...


代码解读：

    pool.apply_async()用来向进程池提交目标请求

    close()会等待池中的worker进程执行结束再关闭pool

    调用join函数，等待所有子进程执行完成
    
    在调用join前要先调用close
    
    在输出的结果中，子线程0,1,2,3是立刻执行，子进程4要等待其中一个子进程执行完成后在开始执行，
    这是因为开始的时候给Pool设置的大小是4，所以只能同时执行4个进程，而range(5)生成了5个子进程，
    这是Pool有意设计的限制，并不是操作系统的限制。
    
    改成 p = Pool(5)后，可以同时跑5个子线程，结果如下：
    
        父进程 10044.
        等待所有子进程执行完成...
        子进程执行 0 (8552)
        子进程执行 1 (3520)
        子进程执行 2 (8248)
        子进程执行 3 (8332)
        子进程执行 4 (8240)
        子进程执行 0  time = 1524379424.87
        子进程执行 1  time = 1524379424.87
        子进程执行 2  time = 1524379424.87
        子进程执行 3  time = 1524379424.87
        子进程执行 4  time = 1524379424.91
        所有子进程执行完成...
        
        
    由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。
'''